Filename: SCRUB.py

Line #    Mem usage    Increment   Line Contents
================================================
    50     63.4 MiB      0.0 MiB   @ profile(stream=mf)
    51                             def get_line_count(fh,block):
    52     63.4 MiB      0.0 MiB       block_size = block.end + 1 - block.start
    53     63.4 MiB      0.0 MiB       count_of_characters_read = 0
    54     63.4 MiB      0.0 MiB       line_count = 0
    55     63.4 MiB      0.0 MiB       fh.Seek(block.start)
    56                             
    57     63.4 MiB      0.0 MiB       while count_of_characters_read < block_size:
    58     63.4 MiB     -0.0 MiB           buffer_size = min(1000,block_size-count_of_characters_read)
    59     63.4 MiB      0.0 MiB           buff = np.empty(buffer_size, dtype=str)
    60     63.4 MiB      0.0 MiB           fh.Read([buff, MPI.CHAR])
    61                             
    62     63.4 MiB      0.0 MiB           for i in range(buffer_size):
    63     63.4 MiB      0.0 MiB               if buff[i] == "\n":
    64     63.4 MiB      0.0 MiB                   line_count += 1
    65                             
    66     63.4 MiB      0.0 MiB           count_of_characters_read += buffer_size
    67     63.4 MiB      0.0 MiB       return line_count


Filename: SCRUB.py

Line #    Mem usage    Increment   Line Contents
================================================
    71     63.3 MiB      0.0 MiB   @ profile(stream=mf)
    72                             def adjust_blocks(fh,block,rank, nprocs):
    73     63.3 MiB      0.0 MiB       buffer_size = 100
    74     63.3 MiB      0.0 MiB       buffer = np.empty(buffer_size, dtype=str)
    75     63.3 MiB      0.0 MiB       error = fh.Set_errhandler(MPI.ERRORS_RETURN)
    76                             
    77                                 # adjust the block start
    78     63.3 MiB      0.0 MiB       if not(rank == 0):
    79     63.3 MiB      0.0 MiB           fh.Seek(block.start)
    80     63.3 MiB      0.0 MiB           if error is not None:
    81                                         print("Could not seek file")
    82                                         sys.exit()
    83                             
    84     63.4 MiB      0.1 MiB           fh.Read([buffer, MPI.CHAR])
    85     63.4 MiB      0.0 MiB           if error is not None:
    86                                         print("Could not read file")
    87                                         sys.exit()
    88                             
    89     63.4 MiB      0.0 MiB           for i in range(buffer_size):
    90     63.4 MiB      0.0 MiB               if buffer[i] == "\n":
    91     63.4 MiB      0.0 MiB                   block.start += i + 1
    92     63.4 MiB      0.0 MiB                   break
    93                             
    94                                 # adjust the block end
    95     63.4 MiB      0.0 MiB       if not(rank == nprocs-1):
    96     63.4 MiB      0.0 MiB           fh.Seek(block.end)
    97     63.4 MiB      0.0 MiB           if error is not None:
    98                                         print("Call to seek file failed")
    99                                         sys.exit()
   100                             
   101     63.4 MiB      0.0 MiB           fh.Read([buffer, MPI.CHAR])
   102     63.4 MiB      0.0 MiB           if error is not None:
   103                                         print("Call to read file failed")
   104                                         sys.exit()
   105                             
   106     63.4 MiB      0.0 MiB           for i in range(buffer_size):
   107     63.4 MiB      0.0 MiB               if buffer[i] == "\n":
   108     63.4 MiB      0.0 MiB                   block.end += i
   109     63.4 MiB      0.0 MiB                   break
   110                             
   111                                 #print("Process: {}, Adjusted block: [{}, {}]".format(rank,block.start,block.end))
   112     63.4 MiB      0.0 MiB       line_count = get_line_count(fh,block)
   113                                 #print("Process: {}, Line Count: {}".format(rank,line_count))
   114                             
   115     63.4 MiB      0.0 MiB       return block, line_count


Filename: SCRUB.py

Line #    Mem usage    Increment   Line Contents
================================================
   186     63.5 MiB      0.0 MiB   @ profile(stream=mf)
   187                             def identify_noise(file, block, first_index, count):
   188     63.5 MiB      0.0 MiB       with open(file, 'r') as fh:
   189     63.5 MiB      0.0 MiB           noise_list = []
   190     63.5 MiB      0.0 MiB           fh.seek(block.start)
   191     63.5 MiB      0.0 MiB           total = 0  # number of characters of the block read
   192     63.5 MiB      0.0 MiB           current_line_index = first_index
   193     63.5 MiB      0.1 MiB           t = date_parse("00010101:00:00:00.000000")  # default initial timestamp for 1st comparison
   194     64.1 MiB      0.6 MiB           while count > 0:
   195     64.1 MiB      0.0 MiB               buffer_size = min(1000, count)  # number of rows to be processed at a time
   196     64.1 MiB      0.0 MiB               count -= buffer_size
   197     64.1 MiB      0.0 MiB               lines = islice(fh, buffer_size)
   198     64.1 MiB      0.0 MiB               data = []
   199     64.1 MiB      0.0 MiB               for tick in lines:
   200     64.1 MiB      0.0 MiB                   total += len(tick)
   201     64.1 MiB      0.0 MiB                   is_valid_bool, tick_list,reason = check_format(tick)
   202     64.1 MiB      0.0 MiB                   if not is_valid_bool:
   203     64.1 MiB      0.0 MiB                       logging.debug("Index: {}, Reason: {}".format(current_line_index,reason))
   204     64.1 MiB      0.0 MiB                       noise_list.append(current_line_index)
   205                                             else:
   206     64.1 MiB      0.0 MiB                       data.append(Ticks(tick_list[0],tick_list[1],tick_list[2],current_line_index))
   207     64.1 MiB      0.0 MiB                   current_line_index += 1
   208                             
   209     64.1 MiB      0.0 MiB               counts = Counter()
   210     64.1 MiB      0.0 MiB               for i in data:
   211     64.1 MiB      0.0 MiB                   if i.timestamp in counts:
   212     64.1 MiB      0.0 MiB                       counts[i.timestamp] += 1
   213                                             else:
   214     64.1 MiB      0.0 MiB                       counts[i.timestamp] = 1
   215                             
   216     64.1 MiB      0.0 MiB               for i in data:
   217     64.1 MiB      0.0 MiB                   if counts[i.timestamp] > 1:
   218     64.1 MiB      0.0 MiB                       logging.debug("Index: {}, Reason: Duplicate timestamp".format(i.index))
   219     64.1 MiB      0.0 MiB                       noise_list.append(i.index)
   220     64.1 MiB      0.0 MiB                       del i
   221                             
   222     64.1 MiB      0.0 MiB               for i in range(len(data)):
   223     64.1 MiB      0.0 MiB                   if t == date_parse("00010101:00:00:00.000000"):
   224     64.0 MiB     -0.1 MiB                       for j in range(i,len(data)-1):
   225     64.0 MiB      0.0 MiB                           if abs(data[j].timestamp-data[j+1].timestamp).total_seconds() <= 3:
   226     64.0 MiB      0.0 MiB                               t = data[j].timestamp
   227     64.0 MiB      0.0 MiB                               break
   228                             
   229     64.1 MiB      0.1 MiB                   is_valid_result = isvalid(data[i],t)
   230                             
   231     64.1 MiB      0.0 MiB                   if not is_valid_result.bool:
   232     64.1 MiB      0.0 MiB                       logging.debug("Index: {}, Reason: {}".
   233     64.1 MiB      0.0 MiB                                    format(data[i].index,is_valid_result.reason))
   234     64.1 MiB      0.0 MiB                       noise_list.append(data[i].index)
   235                                             else:
   236     64.1 MiB      0.0 MiB                       t = is_valid_result.timestamp
   237                             
   238     64.1 MiB      0.0 MiB       return noise_list


Filename: SCRUB.py

Line #    Mem usage    Increment   Line Contents
================================================
   242     62.9 MiB      0.0 MiB   @ profile(stream=mf)
   243                             def main(argv):
   244     62.9 MiB      0.0 MiB       comm = MPI.COMM_WORLD
   245     62.9 MiB      0.0 MiB       rank = comm.Get_rank()
   246     62.9 MiB      0.0 MiB       nprocs = comm.Get_size()
   247     63.2 MiB      0.3 MiB       fh = MPI.File.Open(comm, argv)
   248     63.2 MiB      0.0 MiB       file_size = fh.Get_size()
   249     63.2 MiB      0.0 MiB       block_size = int(file_size/nprocs)
   250                             
   251     63.2 MiB      0.0 MiB       if file_size < nprocs:
   252                                     print("Insufficient data in file")
   253                             
   254                                 # divide file into nominal blocks for each process (same length)
   255     63.2 MiB      0.0 MiB       block_start = rank * block_size
   256                             
   257     63.2 MiB      0.0 MiB       if not(rank == nprocs-1):
   258                                     block_end = block_start + block_size - 1
   259                                 else:
   260     63.2 MiB      0.0 MiB           block_end = file_size
   261                             
   262     63.2 MiB      0.0 MiB       block = Block(block_start,block_end)
   263                                 #print("Process {}: Block: [{}, {}]".format(rank,block.start,block.end))
   264                             
   265                                 # get adjusted blocks so that a block starts at a new tick and ends at the end of a tick
   266     63.3 MiB      0.1 MiB       block, line_count = adjust_blocks(fh,block,rank, nprocs)
   267     63.4 MiB      0.0 MiB       fh.Close()
   268                                 # each node sends their line_count to all the nodes with rank greater than itself
   269     63.4 MiB      0.0 MiB       for i in range(rank+1, nprocs):
   270                                     comm.send(line_count, dest=i)
   271                             
   272     63.4 MiB      0.0 MiB       got_all_blocks_index = datetime.now()
   273                             
   274                                 # process each block
   275                             
   276                                 """if rank is zero the index of first tick is zero else
   277                                 index of first tick is the sum of line_count of processes with rank less than the node's rank.
   278                                 Once each node has the index of the first tick in its block, further processing starts
   279                                 Each node sends the list of noise to root node (0). Root node receives all noises and writes them into
   280                                 noise.txt"""
   281                             
   282     63.4 MiB      0.0 MiB       first_index = 0  # index of the first tick in block
   283                             
   284     63.4 MiB      0.0 MiB       if rank == 0:
   285                                     noise_list = identify_noise(argv,block,first_index,line_count)
   286                             
   287                                 else:
   288     63.4 MiB      0.1 MiB           for i in range(rank):
   289     63.4 MiB      0.0 MiB               first_index += comm.recv(source=i)
   290                             
   291     64.1 MiB      0.7 MiB           noise_list = identify_noise(argv,block,first_index,line_count)
   292     64.1 MiB      0.0 MiB           comm.send(noise_list,dest=0)
   293                             
   294     64.1 MiB      0.0 MiB       finish_scrubbing = datetime.now()
   295                             
   296     64.1 MiB      0.0 MiB       if rank == 0:
   297                                     start_writing_noise = datetime.now()
   298                                     with open("noise.txt","w") as noise:
   299                                         for index in noise_list:
   300                                             noise.write(str(index)+"\n")
   301                                         for i in range(1,nprocs):
   302                                             noise_list = comm.recv(source=i)
   303                                             for index in noise_list:
   304                                                 noise.write(str(index)+"\n")
   305                             
   306                                     finish_writing_noise = datetime.now()
   307                             
   308                                     logging.info("Time Profile")
   309                                     logging.info("Time to get blocks: {}".format((got_all_blocks_index-start_time).total_seconds()))
   310                                     logging.info("Time to scrub: {}".format((finish_scrubbing-got_all_blocks_index).total_seconds()))
   311                                     logging.info("Time taken to write noise.txt: {}".format((finish_writing_noise-start_writing_noise).total_seconds()))
   312                                     logging.info("Total time taken is: {}".format((finish_writing_noise-start_time).total_seconds()))
   313                             
   314                                     logging.info("Memory profile")
   315                                     logging.info(h.heap())
   316                             
   317     63.8 MiB     -0.3 MiB       MPI.Finalize()


