Facts about the data:

1. Each row has 3 datapoints: Timestamp, Price, Units Traded
2. Timestamp is in format YYYYMMDD:HH:MM:SS.SSSSSS (seconds as float to capture microsecond)
3. Price is float
4. Units Traded is integer
5. Price and Units can be zero or negative
6. Timestamps:  -can be duplicate
				-not in order
				-difference between two consecutive timestamps can be as large as possible
7. Data is a stream of network data packets

Facts about network latency:

1. Network latency is in milliseconds
2. Latency should not exceed more than 2-3 seconds considering the packet travels the largest distance

Check points:

1. All three items in a row should be in right format
2. The Price and Units Traded should not be zero or negative and should be within 2 standard deviations from mean
3. Rows with duplicate timestamps should be removed as those are unreliable and we have no mechanism to check which one is real data
4. Two consecutive rows should have timestamps within 3 seconds range

Process:
SCRUB
Sequential Step 1: 3 Steps will run in parallel in this step
    Step 1: Divide file into nominal blocks
    Step 2: Adjust block start and end to get the final blocks to be processed by each node
    Step 3: Get the count of lines in each block
    Step 4: Broadcast count/ once each block gets the line count they should send it to root node

Sequential Step 2: Once each node provides the line count, root node will calculate the index of first tick in each block

Sequential Step 3: Root node will send the index to each node and then they will start further processing

Sequential Step 4: Information with each node: Block start and end, file, index of the first row in block
Each node processes their block as follows
    Step 1: Parse data in chunks of size 10000 (about 200 rows) and create objects of class Ticks with 3 features as in file and index
    Step 2: For each chunk check the format. If incorrect format, write index to noise
    Step 3: Check for network latency, relative price and unit using standard deviation (price and unit should be within 2 std deviations)
    Step 4: The ticks that get past all checks will be signals so sort them in order of timestamp and add them to signal


NORMAL
Step 1: Divide signal in blocks
Step 2: Read each block iteratively in chunks
Step 3: Plot histogram with X axis range [-150, 150]
Step 4: Compute return for each row and add it to histogram
Step 5: Check histogram for normality by computing curse stats
